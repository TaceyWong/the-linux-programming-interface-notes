#《THE LINUX PROGRAMMING INTERFACE：A Linux and UNIX® System Programming Handbook》阅读笔记 #

**此书已经有中文版:[《Linux/Unix系统编程手册》](https://item.jd.com/11383763.html)**

目录：

第1章　历史和标准<br>1.1　UNIX和C语言简史<br>1.2　Linux简史<br>1.2.1　GNU项目<br>1.2.2　Linux内核<br>1.3　标准化<br>1.3.1　C编程语言<br>1.3.2　首个POSIX标准<br>1.3.3　X/Open公司和The Open Group<br>1.3.4　SUSv3和POSIX.1-2001<br>1.3.5　SUSv4和POSIX.1-2008<br>1.3.6　UNIX标准时间表<br>1.3.7　实现标准<br>1.3.8　Linux、标准、Linux标准规范（Linux Standard Base）<br>1.4　总结<br>第2章　基本概念<br>2.1　操作系统的核心-内核<br>2.2　shell<br>2.3　用户和组<br>2.4　单根目录层级、目录、链接及文件<br>2.5　文件I/O模型<br>2.6　程序<br>2.7　进程<br>2.8　内存映射<br>2.9　静态库和共享库<br>2.10　进程间通信及同步<br>2.11　信号<br>2.12　线程<br>2.13　进程组和shell任务控制<br>2.14　会话、控制终端和控制进程<br>2.15　伪终端<br>2.16　日期和时间<br>2.17　客户端服务器架构<br>2.18　实时性<br>2.19　/proc文件系统<br>2.20　总结<br>第3章　系统编程概念<br>3.1　系统调用<br>3.2　库函数<br>3.3　标准C语言函数库；GNU C语言函数库（glibc）<br>3.4　处理来自系统调用和库函数的错误<br>3.5　关于本书示例程序的注意事项<br>3.5.1　命令行选项及参数<br>3.5.2　常用的函数及头文件<br>3.6　可移植性问题<br>3.6.1　特性测试宏<br>3.6.2　系统数据类型<br>3.6.3　其他的可移植性问题<br>3.7　总结<br>3.8　练习<br>第4章　文件I/O：通用的I/O模型<br>4.1　概述<br>4.2　通用I/O<br>4.3　打开一个文件：open<br>4.3.1　open调用中的flags参数<br>4.3.2　open函数的错误<br>4.3.3　creat系统调用<br>4.4　读取文件内容：read<br>4.5　数据写入文件：write<br>4.6　关闭文件：close<br>4.7　改变文件偏移量：lseek<br>4.8　通用I/O模型以外的操作：ioctl<br>4.9　总结<br>4.10　练习<br>第5章　深入探究文件I/O<br>5.1　原子操作和竞争条件<br>5.2　文件控制操作：fcntl<br>5.3　打开文件的状态标志<br>5.4　文件描述符和打开文件之间的关系<br>5.5　复制文件描述符<br>5.6　在文件特定偏移量处的I/O：pread和pwrite<br>5.7　分散输入和集中输出（Scatter-Gather I/O）：readv和writev<br>5.8　截断文件：truncate和ftruncate系统调用<br>5.9　非阻塞I/O<br>5.10　大文件I/O<br>5.11　/dev/fd目录<br>5.12　创建临时文件<br>5.13　总结<br>5.14　练习<br>第6章　进程<br>6.1　进程和程序<br>6.2　进程号和父进程号<br>6.3　进程内存布局<br>6.4　虚拟内存管理<br>6.5　栈和栈帧<br>6.6　命令行参数（argc， argv）<br>6.7　环境列表<br>6.8　执行非局部跳转：setjmp和longjmp<br>6.9　总结<br>6.9　练习<br>第7章　内存分配<br>7.1　在堆上分配内存<br>7.1.1　调整program break：brk和sbrk<br>7.1.2　在堆上分配内存：malloc和free<br>7.1.3　malloc和free的实现<br>7.1.4　在堆上分配内存的其他方法<br>7.2　在堆栈上分配内存：alloca<br>7.3　总结<br>7.4　练习<br>第8章　用户和组<br>8.1　密码文件：/etc/passwd<br>8.2　shadow密码文件：/etc/shadow<br>8.3　组文件：/etc/group<br>8.4　获取用户和组的信息<br>8.5　密码加密和用户认证<br>8.6　总结<br>8.7　练习<br>第9章　进程凭证<br>9.1　实际用户ID和实际组ID<br>9.2　有效用户ID和有效组ID<br>9.3　Set-User-ID和Set-Group-ID程序<br>9.4　保存set-user-ID和保存set-group-ID<br>9.5　文件系统用户ID和组ID<br>9.6　辅助组ID<br>9.7　获取和修改进程凭证<br>9.7.1　获取和修改实际、有效和保存设置标识<br>9.7.2　获取和修改文件系统ID<br>9.7.3　获取和修改辅助组ID<br>9.7.4　修改进程凭证的系统调用总结<br>9.7.5　示例：显示进程凭证<br>9.8　总结<br>9.9　习题<br>第10章　时间<br>10.1　日历时间（Calendar Time）<br>10.2　时间转换函数<br>10.2.1　将time_t转换为可打印格式<br>10.2.2　time_t和分解时间之间的转换<br>10.2.3　分解时间和打印格式之间的转换<br>10.3　时区<br>10.4　地区（Locale）<br>10.5　更新系统时钟<br>10.6　软件时钟（jiffies）<br>10.7　进程时间<br>10.8　总结<br>10.9　练习<br>第11章　系统限制和选项<br>11.1　系统限制<br>11.2　在运行时获取系统限制（和选项）<br>11.3　运行时获取与文件相关的限制（和选项）<br>11.4　不确定的限制<br>11.5　系统选项<br>11.6　总结<br>11.7　练习<br>第12章　系统和进程信息<br>12.1　/proc文件系统<br>12.1.1　获取与进程有关的信息：/proc/PID<br>12.1.2　/proc 目录下的系统信息<br>12.1.3　访问/proc文件<br>12.2　系统标识：uname<br>12.3　总结<br>12.4　练习<br>第13章　文件I/O缓冲<br>13.1　文件I/O的内核缓冲：缓冲区高速缓存<br>13.2　stdio库的缓冲<br>13.3　控制文件I/O的内核缓冲<br>13.4　I/O缓冲小结<br>13.5　就I/O模式向内核提出建议<br>13.6　绕过缓冲区高速缓存：直接I/O<br>13.7　混合使用库函数和系统调用进行文件I/O<br>13.8　总结<br>13.9　练习<br>第14章　系统编程概念<br>14.1　设备专用文件（设备文件）<br>14.2　磁盘和分区<br>14.3　文件系统<br>14.4　i节点<br>14.5　虚拟文件系统（VFS）<br>14.6　日志文件系统<br>14.7　单根目录层级和挂载点<br>14.8　文件系统的挂载和卸载<br>14.8.1　挂载文件系统：mount<br>14.8.2　卸载文件系统：umount和umount2<br>14.9　高级挂载特性<br>14.9.1　在多个挂载点挂载文件系统<br>14.9.2　多次挂载同一挂载点<br>14.9.3　基于每次挂载的挂载标志<br>14.9.4　绑定挂载<br>14.9.5　递归绑定挂载<br>14.10　虚拟内存文件系统：tmpfs<br>14.11　获得与文件系统有关的信息：statvfs<br>14.12　总结<br>14.13　练习<br>第15章　文件属性<br>15.1　获取文件信息：stat<br>15.2　文件时间戳<br>15.2.1　使用utime和utimes来改变文件时间戳<br>15.2.2　使用utimensat和futimens改变文件时间戳<br>15.3　文件属主<br>15.3.1　新建文件的属主<br>15.3.2　改变文件属主：chown、fchown和lchown<br>15.4　文件权限<br>15.4.1　普通文件的权限<br>15.4.2　目录权限<br>15.4.3　权限检查算法<br>15.4.4　检查对文件的访问权限：access<br>15.4.5　Set-User-ID、Set-Group-ID和Sticky位<br>15.4.6　进程的文件模式创建掩码：umask<br>15.4.7　更改文件权限：chmod和fchmod<br>15.5　I节点标志（ext2扩展文件属性）<br>15.6　总结<br>15.7　练习<br>第16章　扩展属性<br>16.1　概述<br>16.2　扩展属性的实现细节<br>16.3　操控扩展属性的系统调用<br>16.4　总结<br>16.5　练习<br>第17章　访问控制列表<br>17.1　概述<br>17.2　ACL权限检查算法<br>17.3　ACL的长、短文本格式<br>17.4　ACL_mask型ACE和ACL组分类<br>17.5　getfacl和setfacl命令<br>17.6　默认ACL与文件创建<br>17.7　ACL在实现方面的限制<br>17.8　ACL API<br>17.9　总结<br>17.10　练习<br>第18章　目录与链接<br>18.1　目录和（硬）链接<br>18.2　符号（软）链接<br>18.3　创建和移除（硬）链接：link和 unlink<br>18.4　更改文件名：rename<br>18.5　使用符号链接：symlink和readlink<br>18.6　创建和移除目录：mkdir和rmdir<br>18.7　移除一个文件或目录：remove<br>18.8　读目录：opendir和readdir<br>18.9　文件树遍历：nftw<br>18.10　进程的当前工作目录<br>18.11　针对目录文件描述符的相关操作<br>18.12　改变进程的根目录：chroot<br>18.13　解析路径名：realpath<br>18.14　解析路径名字符串：dirname和basename<br>18.15　总结<br>18.16　练习<br>第19章　监控文件事件<br>19.1　概述<br>19.2　inotify API<br>19.3　inotify事件<br>19.4　读取inotify事件<br>19.5　队列限制和/proc文件<br>19.6　监控文件的旧有系统：dnotify<br>19.7　总结<br>19.8　练习<br>第20章　信号：基本概念<br>20.1　概念和概述<br>20.2　信号类型和默认行为<br>20.3　改变信号处置：signal<br>20.4　信号处理器简介<br>20.5　发送信号：kill<br>20.6　检查进程的存在<br>20.7　发送信号的其他方式：raise和killpg<br>20.8　显示信号描述<br>20.9　信号集<br>20.10　信号掩码（阻塞信号传递）<br>20.11　处于等待状态的信号<br>20.12　不对信号进行排队处理<br>20.13　改变信号处置：sigaction<br>20.14　等待信号：pause<br>20.15　总结<br>20.16　练习<br>第21章　信号：信号处理器函数<br>21.1　设计信号处理器函数<br>21.1.1　再论信号的非队列化处理<br>21.1.2　可重入函数和异步信号安全函数<br>21.1.3　全局变量和sig_atomic_t数据类型<br>21.2　终止信号处理器函数的其他方法<br>21.2.1　在信号处理器函数中执行非本地跳转<br>21.2.2　异常终止进程：abort<br>21.3　在备选栈中处理信号：sigaltstack<br>21.4　SA_SIGINFO标志<br>21.5　系统调用的中断和重启<br>21.6　总结<br>21.7　练习<br>第22章　信号：高级特性<br>22.1　核心转储文件<br>22.2　传递、处置及处理的特殊情况<br>22.3　可中断和不可中断的进程睡眠状态<br>22.4　硬件产生的信号<br>22.5　信号的同步生成和异步生成<br>22.6　信号传递的时机与顺序<br>22.7　signal的实现及可移植性<br>22.8　实时信号<br>22.8.1　发送实时信号<br>22.8.2　处理实时信号<br>22.9　使用掩码来等待信号：sigsuspend<br>22.10　以同步方式等待信号<br>22.11　通过文件描述符来获取信号<br>22.12　利用信号进行进程间通信<br>22.13　早期的信号API（System V和BSD）<br>22.14　总结<br>22.15　练习<br>第23章　定时器与休眠<br>23.1　间隔定时器<br>23.2　定时器的调度及精度<br>23.3　为阻塞操作设置超时<br>23.4　暂停运行（休眠）一段固定时间<br>23.4.1　低分辨率休眠：sleep<br>23.4.2　高分辨率休眠：nanosleep<br>23.5　POSIX时钟<br>23.5.1　获取时钟的值：clock_gettime<br>23.5.2　设置时钟的值：clock_settime<br>23.5.3　获取特定进程或线程的时钟ID<br>23.5.4　高分辨率休眠的改进版：clock_nanosleep<br>23.6　POSIX间隔式定时器<br>23.6.1　创建定时器：timer_create<br>23.6.2　配备和解除定时器：timer_settime<br>23.6.3　获取定时器的当前值：timer_gettime<br>23.6.4　删除定时器：timer_delete<br>23.6.5　通过信号发出通知<br>23.6.6　定时器溢出<br>23.6.7　通过线程来通知<br>23.7　利用文件描述符进行通知的定时器：timerfd API<br>23.8　总结<br>23.9　练习<br>第24章　进程的创建<br>24.1　fork、exit、wait以及execve的简介<br>24.2　创建新进程：fork<br>24.2.1　父、子进程间的文件共享<br>24.2.2　fork的内存语义<br>24.3　系统调用vfork<br>24.4　fork之后的竞争条件（Race Condition）<br>24.5　同步信号以规避竞争条件<br>24.6　总结<br>24.7　练习<br>第25章　进程的终止<br>25.1　进程的终止：_exit和exit<br>25.2　进程终止的细节<br>25.3　退出处理程序<br>25.4　fork、stdio缓冲区以及_exit之间的交互<br>25.5　总结<br>25.6　练习<br>第26章　监控子进程<br>26.1　等待子进程<br>26.1.1　系统调用wait<br>26.1.2　系统调用waitpid<br>26.1.3　等待状态值<br>26.1.4　从信号处理程序中终止进程<br>26.1.5　系统调用waitid<br>26.1.6　系统调用wait3和wait4<br>26.2　孤儿进程与僵尸进程<br>26.3　SIGCHLD信号<br>26.3.1　为SIGCHLD建立信号处理程序<br>26.3.2　向已停止的子进程发送SIGCHLD信号<br>26.3.3　忽略终止的子进程<br>26.4　总结<br>26.5　练习<br>第27章　程序的执行<br>27.1　执行新程序：execve<br>27.2　exec库函数<br>27.2.1　环境变量PATH<br>27.2.2　将程序参数指定为列表<br>27.2.3　将调用者的环境传递给新程序<br>27.2.4　执行由文件描述符指代的程序：fexecve<br>27.3　解释器脚本<br>27.4　文件描述符与exec<br>27.5　信号与exec<br>27.6　执行shell命令：system<br>27.7　system的实现<br>27.8　总结<br>27.9　练习<br>第28章　详述进程创建和程序执行<br>28.1　进程记账<br>28.2　系统调用clone<br>28.2.1　clone的flags参数<br>28.2.2　因克隆生成的子进程而对waitpid进行的扩展<br>28.3　进程的创建速度<br>28.4　exec和fork对进程属性的影响<br>28.5　总结<br>28.6　练习<br>第29章　线程：介绍<br>29.1　概述<br>29.2　Pthreads API的详细背景<br>29.3　创建线程<br>29.4　终止线程<br>29.5　线程ID（Thread ID）<br>29.6　连接（joining）已终止的线程<br>29.7　线程的分离<br>29.8　线程属性<br>29.9　线程VS进程<br>29.10　总结<br>29.11　练习<br>第30章　线程：线程同步<br>30.1　保护对共享变量的访问：互斥量<br>30.1.1　静态分配的互斥量<br>30.1.2　加锁和解锁互斥量<br>30.1.3　互斥量的性能<br>30.1.4　互斥量的死锁<br>30.1.5　动态初始化互斥量<br>30.1.6　互斥量的属性<br>30.1.7　互斥量类型<br>30.2　通知状态的改变：条件变量（Condition Variable）<br>30.2.1　由静态分配的条件变量<br>30.2.2　通知和等待条件变量<br>30.2.3　测试条件变量的判断条件（predicate）<br>30.2.4　示例程序：连接任意已终止线程<br>30.2.5　经由动态分配的条件变量<br>30.3　总结<br>30.4　练习<br>第31章　线程：线程安全和每线程存储<br>31.1　线程安全（再论可重入性）<br>31.2　一次性初始化<br>31.3　线程特有数据<br>31.3.1　库函数视角下的线程特有数据<br>31.3.2　线程特有数据API概述<br>31.3.3　线程特有数据API详述<br>31.3.4　使用线程特有数据API<br>31.3.5　线程特有数据的实现限制<br>31.4　线程局部存储<br>31.5　总结<br>31.6　练习<br>第32章　线程：线程取消<br>32.1　取消一个线程<br>32.2　取消状态及类型<br>32.3　取消点<br>32.4　线程可取消性的检测<br>32.5　清理函数（cleanup handler）<br>32.6　异步取消<br>32.7　总结<br>第33章　线程：更多细节<br>33.1　线程栈<br>33.2　线程和信号<br>33.2.1　UNIX信号模型如何映射到线程中<br>33.2.2　操作线程信号掩码<br>33.2.3　向线程发送信号<br>33.2.4　妥善处理异步信号<br>33.3　线程和进程控制<br>33.4　线程实现模型<br>33.5　Linux POSIX线程的实现<br>33.5.1　LinuxThreads<br>33.5.2　NPTL<br>33.5.3　哪一种线程实现<br>33.6　Pthread API的高级特性<br>33.7　总结<br>33.8　练习

<br>第34章　进程组、会话和作业控制<br>34.1　概述<br>34.2　进程组<br>34.3　会话<br>34.4　控制终端和控制进程<br>34.5　前台和后台进程组<br>34.6　SIGHUP信号<br>34.6.1　在shell中处理SIGHUP信号<br>34.6.2　SIGHUP和控制进程的终止<br>34.7　作业控制<br>34.7.1　在shell中使用作业控制<br>34.7.2　实现作业控制<br>34.7.3　处理作业控制信号<br>34.7.4　孤儿进程组（SIGHUP回顾）<br>34.8　总结<br>34.9　习题<br>第35章　进程优先级和调度<br>35.1　进程优先级（nice值）<br>35.2　实时进程调度概述<br>35.2.1　SCHED_RR策略<br>35.2.2　SCHED_FIFO策略<br>35.2.3　SCHED_BATCH和SCHED_IDLE策略<br>35.3　实时进程调用API<br>35.3.1　实时优先级范围<br>35.3.2　修改和获取策略和优先级<br>35.3.3　释放CPU<br>35.3.4　SCHED_RR时间片<br>35.4　CPU亲和力<br>35.5　总结<br>35.6　习题<br>第36章　进程资源<br>36.1 进程资源使用<br>36.2 进程资源限制<br>36.3 特定资源限制细节<br>36.4 总结<br>36.5 习题<br>第37章　DAEMON<br>37.1 概述<br>37.2 创建一个daemon<br>37.3 编写daemon指南<br>37.4 使用SIGHUP重新初始化一个daemon<br>37.5 使用syslog记录消息和错误<br>37.5.1 概述<br>37.5.2 syslog API<br>37.5.3 /etc/syslog.conf文件<br>37.6 总结<br>37.7 习题<br>第38章　编写安全的特权程序<br>38.1 是否需要一个Set-User-ID或Set-Group-ID程序？<br>38.2 以最小权限操作<br>38.3 小心执行程序<br>38.4 避免暴露敏感信息<br>38.5 确定进程的边界<br>38.6 小心信号和竞争条件<br>38.7 执行文件操作和文件I/O的缺陷<br>38.8 不要完全相信输入和环境<br>38.9 小心缓冲区溢出<br>38.10 小心拒绝服务攻击<br>38.11 检查返回状态和安全地处理失败情况<br>38.12 总结<br>38.13 习题<br>第39章　能力<br>39.1 能力基本原理<br>39.2 Linux能力<br>39.3 进程和文件能力<br>39.3.1 进程能力<br>39.3.2 文件能力<br>39.3.3 进程许可和有效能力集的目的<br>39.3.4 文件许可和有效能力集的目的<br>39.3.5 进程和文件可继承集的目的<br>39.3.6 在shell中给文件赋予能力和查看文件能力<br>39.4 现代能力实现<br>39.5 在exec中转变进程能力<br>39.5.1 能力边界集<br>39.5.2 保持root语义<br>39.6 改变用户ID对进程能力的影响<br>39.7 用编程的方式改变进程能力<br>39.8 创建仅包含能力的环境<br>39.9 发现程序所需的能力<br>39.10 不具备文件能力的老式内核和系统<br>39.11 总结<br>39.12 习题<br>第40章　登录记账<br>40.1 utmp和wtmp文件概述<br>40.2 utmpx API<br>40.3 utmpx结构<br>40.4 从utmp和wtmp文件中检索信息<br>40.5 获取登录名称：getlogin<br>40.6 为登录会话更新utmp和wtmp文件<br>40.7 lastlog文件<br>40.8 总结<br>40.9 习题<br>第41章　共享库基础<br>41.1 目标库<br>41.2 静态库<br>41.3 共享库概述<br>41.4 创建和使用共享库--首回合<br>41.4.1 创建一个共享库<br>41.4.2 位置独立的代码<br>41.4.3 使用一个共享库<br>41.4.4 共享库soname<br>41.5 使用共享库的有用工具<br>41.6 共享库版本和命名规则<br>41.7 安装共享库<br>41.8 兼容与不兼容库比较<br>41.9 升级共享库<br>41.10 在目标文件中指定库搜索目录<br>41.11 在运行时找出共享库<br>41.12 运行时符号解析<br>41.13 使用静态库取代共享库<br>41.14 总结<br>41.15 习题<br>第42章　共享库高级特性<br>42.1 动态加载库<br>42.1.1 打开共享库：dlopen<br>42.1.2 错误诊断：dlerror<br>42.1.3 获取符号的地址：dlsym<br>42.1.4 关闭共享库：dlclose<br>42.1.5 获取与加载的符号相关的信息：dladdr<br>42.1.6 在主程序中访问符号<br>42.2 控制符号的可见性<br>42.3 链接器版本脚本<br>42.3.1 使用版本脚本控制符号的可见性<br>42.3.2 符号版本化<br>42.4 初始化和终止函数<br>42.5 预加载共享库<br>42.6 监控动态链接器：LD_DEBUG<br>42.7 总结<br>42.8 习题<br>第43章　进程间通信简介<br>43.1 IPC工具分类<br>43.2 通信工具<br>43.3 同步工具<br>43.4 IPC工具比较<br>43.5 总结<br>43.6 习题<br>第44章　管道和FIFO<br>44.1　概述<br>44.2　创建和使用管道<br>44.3　将管道作为一种进程同步的方法<br>44.4　使用管道连接过滤器<br>44.5　通过管道与Shell命令进行通信：popen<br>44.6　管道和stdio缓冲<br>44.7　FIFO<br>44.8　使用管道实现一个客户端/服务器应用程序<br>44.9　非阻塞I/O<br>44.10　管道和FIFO中read和write的语义<br>44.11　总结<br>44.12　习题<br>第45章　System V IPC介绍<br>45.1　概述<br>45.2　IPC Key<br>45.3　关联数据结构和对象权限<br>45.4　IPC标识符和客户端/服务器应用程序<br>45.5　System V IPC get调用使用的算法<br>45.6　ipcs和ipcrm命令<br>45.7　获取所有IPC对象列表<br>45.8　IPC限制<br>45.9　总结<br>45.10　习题<br>第46章　System V消息队列<br>46.1　创建或打开一个消息队列<br>46.2　交换消息<br>46.2.1　发送消息<br>46.2.2　接收消息<br>46.3　消息队列控制操作<br>46.4　消息队列关联数据结构<br>46.5　消息队列的限制<br>46.6　显示系统中所有消息队列<br>46.7　使用消息队列实现客户端/服务器应用程序<br>46.8　使用消息队列实现文件服务器应用程序<br>46.9　System V消息队列的缺点<br>46.10　总结<br>46.11　习题<br>第47章　System V信号量<br>47.1　概述<br>47.2　创建或打开一个信号量集<br>47.3　信号量控制操作<br>47.4　信号量关联数据结构<br>47.5　信号量初始化<br>47.6　信号量操作<br>47.7　多个阻塞信号量操作的处理<br>47.8　信号量撤销值<br>47.9　实现一个二元信号量协议<br>47.10　信号量限制<br>47.11　System V信号量的缺点<br>47.12　总结<br>47.13　习题<br>第48章　System V共享内存<br>48.1　概述<br>48.2　创建或打开一个共享内存段<br>48.3　使用共享内存<br>48.4　示例：通过共享内存传输数据<br>48.5　共享内存在虚拟内存中的位置<br>48.6　在共享内存中存储指针<br>48.7　共享内存控制操作<br>48.8　共享内存关联数据结构<br>48.9　共享内存的限制<br>48.10　总结<br>48.11　习题<br>第49章　内存映射<br>49.1　概述<br>49.2　创建一个映射：mmap<br>49.3　解除映射区域：munmap<br>49.4　文件映射<br>49.4.1　私有文件映射<br>49.4.2　共享文件映射<br>49.4.3　边界情况<br>49.4.4　内存保护和文件访问模式交互<br>49.5　同步映射区域：msync<br>49.6　其他mmap标记<br>49.7　匿名映射<br>49.8　重新映射一个映射区域：mremap<br>49.9　MAP_NORESERVE和过度利用交换空间<br>49.10　MAP_FIXED标记<br>49.11　非线性映射：remap_file_pages<br>49.12　总结<br>49.13　习题<br>第50章　虚拟内存操作<br>50.1 改变内存保护：mprotect<br>50.2 内存锁：mlock和mlockatt<br>50.3 确定内存驻留性：mincore<br>50.4 建议后续的内存使用模式：madvise<br>50.5 小结<br>50.6 习题<br>第51章　POSIX IPC介绍<br>51.1 API概述<br>51.2 System V IPC与POSIX IPC比较<br>51.3 总结<br>第52章　POSIX消息队列<br>52.1 概述<br>52.2 打开、关闭和断开链接消息队列<br>52.3 描述符和消息队列之间的关系<br>52.4 消息队列特性<br>52.5 交换消息<br>52.5.1 发送消息<br>52.5.2 接收消息<br>52.5.3 在发送和接收消息时设置超时时间<br>52.6 消息通知<br>52.6.1 通过信号接收通知<br>52.6.2 通过线程接收通知<br>52.7 Linux特有的特性<br>52.8 消息队列限制<br>52.9 POSIX和System V消息队列比较<br>52.10 总结<br>52.11 习题<br>第53章　POSIX信号量<br>53.1 概述<br>53.2 命名信号量<br>53.2.1 打开一个命名信号量<br>53.2.2 关闭一个信号量<br>53.2.3 删除一个命名信号量<br>53.3 信号量操作<br>53.3.1 等待一个信号量<br>53.3.2 发布一个信号量<br>53.3.3 获取信号量的当前值<br>53.4 未命名信号量<br>53.4.1 初始化一个未命名信号量<br>53.4.2 销毁一个未命名信号量<br>53.5 与其他同步技术比较<br>53.6 信号量的限制<br>53.7 总结<br>53.8 习题<br>第54章　POSIX共享内存<br>54.1 概述<br>54.2 创建共享内存对象<br>54.3 使用共享内存对象<br>54.4 删除共享内存对象<br>54.5 共享内存APIs比较<br>54.6 总结<br>54.7 习题<br>第55章　文件加锁<br>55.1 概述<br>55.2 使用flock给文件加锁<br>55.2.1 锁继承与释放的语义<br>55.2.2 flock的限制<br>55.3 使用fcntl给记录加锁<br>55.3.1 死锁<br>55.3.2 示例：一个交互式加锁程序<br>55.3.3 示例：一个加锁函数库<br>55.3.4 锁的限制和性能<br>55.3.5 锁继承和释放的语义<br>55.3.6 锁定饿死和排队加锁请求的优先级<br>55.4 强制加锁<br>55.5 /proc/locks文件<br>55.6 仅运行一个程序的单个实例<br>55.7 老式加锁技术<br>55.8 总结<br>55.9 习题<br>第56章　SOCKET：介绍<br>56.1 概述<br>56.2 创建一个socket：socket<br>56.3 将socket绑定到地址：bind<br>56.4 通用socket地址结构：struct sockaddr<br>56.5 流socket<br>56.5.1 监听接入连接：listen<br>56.5.2 接受连接：accept<br>56.5.3 连接到对等socket：connect<br>56.5.4 流socket I/O<br>56.5.5 连接终止：close<br>56.6 数据报socket<br>56.6.1 交换数据报：recvfrom和sendto<br>56.6.2 在数据报socket上使用connect<br>56.7 总结<br>第57章　SOCKET：UNIX DOMAIN<br>57.1 UNIX domain socket地址：struct sockaddr_un<br>57.2 UNIX domain中的流socket<br>57.3 UNIX domain中的数据报socket<br>57.4 UNIX domain socket权限<br>57.5 创建互联socket对：socketpair<br>57.6 Linux抽象socket名空间<br>57.7 总结<br>57.8 习题<br>第58章　SOCKET：TCP/IP网络基础<br>58.1 因特网<br>58.2 联网协议和层<br>58.3 数据链路层<br>58.4 网络层：IP<br>58.5 IP地址<br>58.6 传输层<br>58.6.1 端口号<br>58.6.2 用户数据报协议（UDP）<br>58.6.3 传输控制协议（TCP）<br>58.7 请求注解（RFC）<br>58.8 总结<br>第59章　SOCKET：Internet DOMAIN<br>59.1 Internet domain socket<br>59.2 网络字节序<br>59.3 数据表示<br>59.4 Internet socket地址<br>59.5 主机和服务转换函数概述<br>59.6 inet_pton和inet_ntop函数<br>59.7 客户端-服务器示例（数据报socket）<br>59.8 域名系统（DNS）<br>59.9 /etc/services文件<br>59.10 独立于协议的主机和服务转换<br>59.10.1 getaddrinfo函数<br>59.10.2 释放addrinfo列表：freeaddrinfo<br>59.10.3 错误诊断：gai_strerror<br>59.10.4 getnameinfo函数<br>59.11 客户端-服务器示例（流式socket）<br>59.12 Internet domain socket库<br>59.13 过时的主机和服务转换API<br>59.13.1 inet_aton和inet_ntoa函数<br>59.13.2 gethostbyname和gethostbyaddr函数<br>59.13.3 getserverbyname和getserverbyport函数<br>59.14 UNIX与Internet domain socket比较<br>59.15 更多信息<br>59.16 总结<br>59.17 习题<br>第60章　SOCKET：服务器设计<br>60.1 迭代型和并发型服务器<br>60.2 迭代型UDP echo服务器<br>60.3 并发型TCP echo服务器<br>60.4 并发型服务器的其他设计方案<br>60.5 inetd（Internet超级服务器）守护进程<br>60.6 总结<br>60.7 练习<br>第61章　SOCKET：高级主题<br>61.1 流式套接字上的部分读和部分写<br>61.2 shutdown系统调用<br>61.3 专用于套接字的I/O系统调用：recv和send<br>61.4 sendfile系统调用<br>61.5 获取套接字地址<br>61.6 深入探讨TCP协议<br>61.6.1 TCP报文的格式<br>61.6.2 TCP序列号和确认机制<br>61.6.3 TCP协议状态机以及状态迁移图<br>61.6.4 TCP连接的建立<br>61.6.5 TCP连接的终止<br>61.6.6 在TCP套接字上调用shutdown<br>61.6.7 TIME_WAIT状态<br>61.7 监视套接字：netstat<br>61.8 使用tcpdump来监视TCP流量<br>61.9 套接字选项<br>61.10 SO_REUSEADDR套接字选项<br>61.11 在accept中继承标记和选项<br>61.12 TCP vs UDP<br>61.13 高级功能<br>61.13.1 带外数据<br>61.13.2 sendmsg和recvmsg系统调用<br>61.13.3 传递文件描述符<br>61.13.4 接收发送端的凭据<br>61.13.5 顺序数据包套接字<br>61.13.6 SCTP以及DCCP传输层协议<br>61.14 总结<br>61.15 练习<br>第62章　终端<br>62.1 整体概览<br>62.2 获取和修改终端属性<br>62.3 stty命令<br>62.4 终端特殊字符<br>62.5 终端标志<br>62.6 终端的I/O模式<br>62.6.1 规范模式<br>62.6.2 非规范模式<br>62.6.3 加工模式、cbreak模式以及原始模式<br>62.7 终端线速（比特率）<br>62.8 终端的行控制<br>62.9 终端窗口大小<br>62.10 终端标识<br>62.11 总结<br>62.12 练习<br>第63章　其他备选的I/O模型<br>63.1 整体概览<br>63.1.1 水平触发和边缘触发<br>63.1.2 在备选的I/O模型中采用非阻塞I/O<br>63.2 I/O多路复用<br>63.2.1 select系统调用<br>63.2.2 poll系统调用<br>63.2.3 文件描述符何时就绪？<br>63.2.4 比较select和poll<br>63.2.5 select和poll存在的问题<br>63.3 信号驱动I/O<br>63.3.1 何时发送"I/O就绪"信号<br>63.3.2 优化信号驱动I/O的使用<br>63.4 epoll编程接口<br>63.4.1 创建epoll实例：epoll_create<br>63.4.2 修改epoll的兴趣列表：epoll_ctl<br>63.4.3 事件等待：epoll_wait<br>63.4.4 深入探究epoll的语义<br>63.4.5 epoll同I/O多路复用的性能对比<br>63.4.6 边缘触发通知<br>63.5 在信号和文件描述符上等待<br>63.5.1 pselect系统调用<br>63.5.2 self-pipe技巧<br>63.6 总结<br>63.7 练习<br>第64章　伪终端<br>64.1 整体概览<br>64.2 UNIX98伪终端<br>64.2.1 打开未使用的主设备：posix_openpt<br>64.2.2 修改从设备属主和权限：grantpt<br>64.2.3 解锁从设备：unlockpt<br>64.2.4 获取从设备名称：ptsname<br>64.3 打开主设备：ptyMasterOpen<br>64.4 将进程连接到伪终端：ptyFork<br>64.5 伪终端I/O<br>64.6 实现script（1）程序<br>64.7 终端属性和窗口大小<br>64.8 BSD风格的伪终端<br>64.9 总结<br>64.10 练习<br>附录A 跟踪系统调用<br>附录B 解析命令行选项<br>附录C 对NULL指针做转型<br>附录D 内核配置<br>附录E 更多信息源<br>附录F 部分习题解答

