#《THE LINUX PROGRAMMING INTERFACE：A Linux and UNIX® System Programming Handbook》阅读笔记 #

**此书已经有中文版:[《Linux/Unix系统编程手册》](https://item.jd.com/11383763.html)**

## 目录：

### 第1章　历史和标准

+ 1.1　UNIX和C语言简史-History and Standards
+ 1.2　Linux简史-A Brief History of Unix and C
+ 1.2.1　GNU项目
+ 1.2.2　Linux内核
+ 1.3　标准化
+ 1.3.1　C编程语言
+ 1.3.2　首个POSIX标准
+ 1.3.3　X/Open公司和The Open Group
+ 1.3.4　SUSv3和POSIX.1-2001M
+ 1.3.5　SUSv4和POSIX.1-2008
+ 1.3.6　UNIX标准时间表
+ 1.3.7　实现标准
+ 1.3.8　Linux、标准、Linux标准规范（Linux Standard Base）
+ 1.4　总结

### 第2章　基本概念

+ 2.1　操作系统的核心-内核
+ 2.2　shell
2.3　用户和组
2.4　单根目录层级、目录、链接及文件
2.5　文件I/O模型
2.6　程序
2.7　进程
2.8　内存映射
2.9　静态库和共享库
2.10　进程间通信及同步
2.11　信号
2.12　线程
2.13　进程组和shell任务控制
2.14　会话、控制终端和控制进程
2.15　伪终端
2.16　日期和时间
2.17　客户端服务器架构
2.18　实时性
2.19　/proc文件系统
2.20　总结

### 第3章　系统编程概念

3.1　系统调用
3.2　库函数
3.3　标准C语言函数库；GNU C语言函数库（glibc）
3.4　处理来自系统调用和库函数的错误
3.5　关于本书示例程序的注意事项
3.5.1　命令行选项及参数
3.5.2　常用的函数及头文件
3.6　可移植性问题
3.6.1　特性测试宏
3.6.2　系统数据类型
3.6.3　其他的可移植性问题
3.7　总结
3.8　练习

### 第4章　文件I/O：通用的I/O模型

+ 4.1　概述
+ 4.2　通用I/O
+ 4.3　打开一个文件：open
+ 4.3.1　open调用中的flags参数
+ 4.3.2　open函数的错误
+ 4.3.3　creat系统调用
+ 4.4　读取文件内容：read
+ 4.5　数据写入文件：write
+ 4.6　关闭文件：close
+ 4.7　改变文件偏移量：lseek
+ 4.8　通用I/O模型以外的操作：ioctl
+ 4.9　总结
+ 4.10　练习

### 第5章　深入探究文件I/O

+ 5.1　原子操作和竞争条件
+ 5.2　文件控制操作：fcntl
+ 5.3　打开文件的状态标志
+ 5.4　文件描述符和打开文件之间的关系
+ 5.5　复制文件描述符
+ 5.6　在文件特定偏移量处的I/O：pread和pwrite
+ 5.7　分散输入和集中输出（Scatter-Gather I/O）：readv和writev
+ 5.8　截断文件：truncate和ftruncate系统调用
+ 5.9　非阻塞I/O
+ 5.10　大文件I/O
+ 5.11　/dev/fd目录
+ 5.12　创建临时文件
+ 5.13　总结
+ 5.14　练习

### 第6章　进程

+ 6.1　进程和程序
+ 6.2　进程号和父进程号
+ 6.3　进程内存布局
+ 6.4　虚拟内存管理
+ 6.5　栈和栈帧
+ 6.6　命令行参数（argcM， argv）
+ 6.7　环境列表
+ 6.8　执行非局部跳转：setjmp和longjmp
+ 6.9　总结
+ 6.9　练习

### 第7章　内存分配

+ 7.1　在堆上分配内存
+ 7.1.1　调整program break：brk和sbrk
+ 7.1.2　在堆上分配内存：malloc和free
+ 7.1.3　malloc和free的实现
+ 7.1.4　在堆上分配内存的其他方法
+ 7.2　在堆栈上分配内存：alloca
+ 7.3　总结
+ 7.4　练习


### 第8章　用户和组

+ 8.1　密码文件：/etc/passwd
+ 8.2　shadow密码文件：/etc/shadow
+ 8.3　组文件：/etc/group
+ 8.4　获取用户和组的信息
+ 8.5　密码加密和用户认证
+ 8.6　总结
+ 8.7　练习

### 第9章　进程凭证

+ 9.1　实际用户ID和实际组ID9.2　有效用户ID和有效组ID9.3　Set-User-ID和Set-Group-ID程序9.4　保存set-user-ID和保存set-group-ID9.5　文件系统用户ID和组ID9.6　辅助组ID9.7　获取和修改进程凭证9.7.1　获取和修改实际、有效和保存设置标识9.7.2　获取和修改文件系统ID9.7.3　获取和修改辅助组ID9.7.4　修改进程凭证的系统调用总结9.7.5　示例：显示进程凭证9.8　总结9.9　习题第10章　时间10.1　日历时间（Calendar Time）10.2　时间转换函数10.2.1　将time_t转换为可打印格式10.2.2　time_t和分解时间之间的转换10.2.3　分解时间和打印格式之间的转换10.3　时区10.4　地区（Locale）10.5　更新系统时钟10.6　软件时钟（jiffies）10.7　进程时间10.8　总结10.9　练习第11章　系统限制和选项11.1　系统限制11.2　在运行时获取系统限制（和选项）11.3　运行时获取与文件相关的限制（和选项）11.4　不确定的限制11.5　系统选项11.6　总结11.7　练习第12章　系统和进程信息12.1　/proc文件系统12.1.1　获取与进程有关的信息：/proc/PID12.1.2　/proc 目录下的系统信息12.1.3　访问/proc文件12.2　系统标识：uname12.3　总结12.4　练习第13章　文件I/O缓冲13.1　文件I/O的内核缓冲：缓冲区高速缓存13.2　stdio库的缓冲13.3　控制文件I/O的内核缓冲13.4　I/O缓冲小结13.5　就I/O模式向内核提出建议13.6　绕过缓冲区高速缓存：直接I/O13.7　混合使用库函数和系统调用进行文件I/O13.8　总结13.9　练习第14章　系统编程概念14.1　设备专用文件（设备文件）14.2　磁盘和分区14.3　文件系统14.4　i节点14.5　虚拟文件系统（VFS）14.6　日志文件系统14.7　单根目录层级和挂载点14.8　文件系统的挂载和卸载14.8.1　挂载文件系统：mount14.8.2　卸载文件系统：umount和umount214.9　高级挂载特性14.9.1　在多个挂载点挂载文件系统14.9.2　多次挂载同一挂载点14.9.3　基于每次挂载的挂载标志14.9.4　绑定挂载14.9.5　递归绑定挂载14.10　虚拟内存文件系统：tmpfs14.11　获得与文件系统有关的信息：statvfs14.12　总结14.13　练习第15章　文件属性15.1　获取文件信息：stat15.2　文件时间戳15.2.1　使用utime和utimes来改变文件时间戳15.2.2　使用utimensat和futimens改变文件时间戳15.3　文件属主15.3.1　新建文件的属主15.3.2　改变文件属主：chown、fchown和lchown15.4　文件权限15.4.1　普通文件的权限15.4.2　目录权限15.4.3　权限检查算法15.4.4　检查对文件的访问权限：access15.4.5　Set-User-ID、Set-Group-ID和Sticky位15.4.6　进程的文件模式创建掩码：umask15.4.7　更改文件权限：chmod和fchmod15.5　I节点标志（ext2扩展文件属性）15.6　总结15.7　练习第16章　扩展属性16.1　概述16.2　扩展属性的实现细节16.3　操控扩展属性的系统调用16.4　总结16.5　练习第17章　访问控制列表17.1　概述17.2　ACL权限检查算法17.3　ACL的长、短文本格式17.4　ACL_mask型ACE和ACL组分类17.5　getfacl和setfacl命令17.6　默认ACL与文件创建17.7　ACL在实现方面的限制17.8　ACL API17.9　总结17.10　练习第18章　目录与链接18.1　目录和（硬）链接18.2　符号（软）链接18.3　创建和移除（硬）链接：link和 unlink18.4　更改文件名：rename18.5　使用符号链接：symlink和readlink18.6　创建和移除目录：mkdir和rmdir18.7　移除一个文件或目录：remove18.8　读目录：opendir和readdir18.9　文件树遍历：nftw18.10　进程的当前工作目录18.11　针对目录文件描述符的相关操作18.12　改变进程的根目录：chroot18.13　解析路径名：realpath18.14　解析路径名字符串：dirname和basename18.15　总结18.16　练习第19章　监控文件事件19.1　概述19.2　inotify API19.3　inotify事件19.4　读取inotify事件19.5　队列限制和/proc文件19.6　监控文件的旧有系统：dnotify19.7　总结19.8　练习第20章　信号：基本概念20.1　概念和概述20.2　信号类型和默认行为20.3　改变信号处置：signal20.4　信号处理器简介20.5　发送信号：kill20.6　检查进程的存在20.7　发送信号的其他方式：raise和killpg20.8　显示信号描述20.9　信号集20.10　信号掩码（阻塞信号传递）20.11　处于等待状态的信号20.12　不对信号进行排队处理20.13　改变信号处置：sigaction20.14　等待信号：pause20.15　总结20.16　练习第21章　信号：信号处理器函数21.1　设计信号处理器函数21.1.1　再论信号的非队列化处理21.1.2　可重入函数和异步信号安全函数21.1.3　全局变量和sig_atomic_t数据类型21.2　终止信号处理器函数的其他方法21.2.1　在信号处理器函数中执行非本地跳转21.2.2　异常终止进程：abort21.3　在备选栈中处理信号：sigaltstack21.4　SA_SIGINFO标志21.5　系统调用的中断和重启21.6　总结21.7　练习第22章　信号：高级特性22.1　核心转储文件22.2　传递、处置及处理的特殊情况22.3　可中断和不可中断的进程睡眠状态22.4　硬件产生的信号22.5　信号的同步生成和异步生成22.6　信号传递的时机与顺序22.7　signal的实现及可移植性22.8　实时信号22.8.1　发送实时信号22.8.2　处理实时信号22.9　使用掩码来等待信号：sigsuspend22.10　以同步方式等待信号22.11　通过文件描述符来获取信号22.12　利用信号进行进程间通信22.13　早期的信号API（System V和BSD）22.14　总结22.15　练习第23章　定时器与休眠23.1　间隔定时器23.2　定时器的调度及精度23.3　为阻塞操作设置超时23.4　暂停运行（休眠）一段固定时间23.4.1　低分辨率休眠：sleep23.4.2　高分辨率休眠：nanosleep23.5　POSIX时钟23.5.1　获取时钟的值：clock_gettime23.5.2　设置时钟的值：clock_settime23.5.3　获取特定进程或线程的时钟ID23.5.4　高分辨率休眠的改进版：clock_nanosleep23.6　POSIX间隔式定时器23.6.1　创建定时器：timer_create23.6.2　配备和解除定时器：timer_settime23.6.3　获取定时器的当前值：timer_gettime23.6.4　删除定时器：timer_delete23.6.5　通过信号发出通知23.6.6　定时器溢出23.6.7　通过线程来通知23.7　利用文件描述符进行通知的定时器：timerfd API23.8　总结23.9　练习第24章　进程的创建24.1　fork、exit、wait以及execve的简介24.2　创建新进程：fork24.2.1　父、子进程间的文件共享24.2.2　fork的内存语义24.3　系统调用vfork24.4　fork之后的竞争条件（Race Condition）24.5　同步信号以规避竞争条件24.6　总结24.7　练习第25章　进程的终止25.1　进程的终止：_exit和exit25.2　进程终止的细节25.3　退出处理程序25.4　fork、stdio缓冲区以及_exit之间的交互25.5　总结25.6　练习第26章　监控子进程26.1　等待子进程26.1.1　系统调用wait26.1.2　系统调用waitpid26.1.3　等待状态值26.1.4　从信号处理程序中终止进程26.1.5　系统调用waitid26.1.6　系统调用wait3和wait426.2　孤儿进程与僵尸进程26.3　SIGCHLD信号26.3.1　为SIGCHLD建立信号处理程序26.3.2　向已停止的子进程发送SIGCHLD信号26.3.3　忽略终止的子进程26.4　总结26.5　练习第27章　程序的执行27.1　执行新程序：execve27.2　exec库函数27.2.1　环境变量PATH27.2.2　将程序参数指定为列表27.2.3　将调用者的环境传递给新程序27.2.4　执行由文件描述符指代的程序：fexecve27.3　解释器脚本27.4　文件描述符与exec27.5　信号与exec27.6　执行shell命令：system27.7　system的实现27.8　总结27.9　练习第28章　详述进程创建和程序执行28.1　进程记账28.2　系统调用clone28.2.1　clone的flags参数28.2.2　因克隆生成的子进程而对waitpid进行的扩展28.3　进程的创建速度28.4　exec和fork对进程属性的影响28.5　总结28.6　练习第29章　线程：介绍29.1　概述29.2　Pthreads API的详细背景29.3　创建线程29.4　终止线程29.5　线程ID（Thread ID）29.6　连接（joining）已终止的线程29.7　线程的分离29.8　线程属性29.9　线程VS进程29.10　总结29.11　练习第30章　线程：线程同步30.1　保护对共享变量的访问：互斥量30.1.1　静态分配的互斥量30.1.2　加锁和解锁互斥量30.1.3　互斥量的性能30.1.4　互斥量的死锁30.1.5　动态初始化互斥量30.1.6　互斥量的属性30.1.7　互斥量类型30.2　通知状态的改变：条件变量（Condition Variable）30.2.1　由静态分配的条件变量30.2.2　通知和等待条件变量30.2.3　测试条件变量的判断条件（predicate）30.2.4　示例程序：连接任意已终止线程30.2.5　经由动态分配的条件变量30.3　总结30.4　练习第31章　线程：线程安全和每线程存储31.1　线程安全（再论可重入性）31.2　一次性初始化31.3　线程特有数据31.3.1　库函数视角下的线程特有数据31.3.2　线程特有数据API概述31.3.3　线程特有数据API详述31.3.4　使用线程特有数据API31.3.5　线程特有数据的实现限制31.4　线程局部存储31.5　总结31.6　练习第32章　线程：线程取消32.1　取消一个线程32.2　取消状态及类型32.3　取消点32.4　线程可取消性的检测32.5　清理函数（cleanup handler）32.6　异步取消32.7　总结第33章　线程：更多细节33.1　线程栈33.2　线程和信号33.2.1　UNIX信号模型如何映射到线程中33.2.2　操作线程信号掩码33.2.3　向线程发送信号33.2.4　妥善处理异步信号33.3　线程和进程控制33.4　线程实现模型33.5　Linux POSIX线程的实现33.5.1　LinuxThreads33.5.2　NPTL33.5.3　哪一种线程实现33.6　Pthread API的高级特性33.7　总结33.8　练习

第34章　进程组、会话和作业控制34.1　概述34.2　进程组34.3　会话34.4　控制终端和控制进程34.5　前台和后台进程组34.6　SIGHUP信号34.6.1　在shell中处理SIGHUP信号34.6.2　SIGHUP和控制进程的终止34.7　作业控制34.7.1　在shell中使用作业控制34.7.2　实现作业控制34.7.3　处理作业控制信号34.7.4　孤儿进程组（SIGHUP回顾）34.8　总结34.9　习题第35章　进程优先级和调度35.1　进程优先级（nice值）35.2　实时进程调度概述35.2.1　SCHED_RR策略35.2.2　SCHED_FIFO策略35.2.3　SCHED_BATCH和SCHED_IDLE策略35.3　实时进程调用API35.3.1　实时优先级范围35.3.2　修改和获取策略和优先级35.3.3　释放CPU35.3.4　SCHED_RR时间片35.4　CPU亲和力35.5　总结35.6　习题第36章　进程资源36.1 进程资源使用36.2 进程资源限制36.3 特定资源限制细节36.4 总结36.5 习题第37章　DAEMON37.1 概述37.2 创建一个daemon37.3 编写daemon指南37.4 使用SIGHUP重新初始化一个daemon37.5 使用syslog记录消息和错误37.5.1 概述37.5.2 syslog API37.5.3 /etc/syslog.conf文件37.6 总结37.7 习题第38章　编写安全的特权程序38.1 是否需要一个Set-User-ID或Set-Group-ID程序？38.2 以最小权限操作38.3 小心执行程序38.4 避免暴露敏感信息38.5 确定进程的边界38.6 小心信号和竞争条件38.7 执行文件操作和文件I/O的缺陷38.8 不要完全相信输入和环境38.9 小心缓冲区溢出38.10 小心拒绝服务攻击38.11 检查返回状态和安全地处理失败情况38.12 总结38.13 习题第39章　能力39.1 能力基本原理39.2 Linux能力39.3 进程和文件能力39.3.1 进程能力39.3.2 文件能力39.3.3 进程许可和有效能力集的目的39.3.4 文件许可和有效能力集的目的39.3.5 进程和文件可继承集的目的39.3.6 在shell中给文件赋予能力和查看文件能力39.4 现代能力实现39.5 在exec中转变进程能力39.5.1 能力边界集39.5.2 保持root语义39.6 改变用户ID对进程能力的影响39.7 用编程的方式改变进程能力39.8 创建仅包含能力的环境39.9 发现程序所需的能力39.10 不具备文件能力的老式内核和系统39.11 总结39.12 习题第40章　登录记账40.1 utmp和wtmp文件概述40.2 utmpx API40.3 utmpx结构40.4 从utmp和wtmp文件中检索信息40.5 获取登录名称：getlogin40.6 为登录会话更新utmp和wtmp文件40.7 lastlog文件40.8 总结40.9 习题第41章　共享库基础41.1 目标库41.2 静态库41.3 共享库概述41.4 创建和使用共享库--首回合41.4.1 创建一个共享库41.4.2 位置独立的代码41.4.3 使用一个共享库41.4.4 共享库soname41.5 使用共享库的有用工具41.6 共享库版本和命名规则41.7 安装共享库41.8 兼容与不兼容库比较41.9 升级共享库41.10 在目标文件中指定库搜索目录41.11 在运行时找出共享库41.12 运行时符号解析41.13 使用静态库取代共享库41.14 总结41.15 习题第42章　共享库高级特性42.1 动态加载库42.1.1 打开共享库：dlopen42.1.2 错误诊断：dlerror42.1.3 获取符号的地址：dlsym42.1.4 关闭共享库：dlclose42.1.5 获取与加载的符号相关的信息：dladdr42.1.6 在主程序中访问符号42.2 控制符号的可见性42.3 链接器版本脚本42.3.1 使用版本脚本控制符号的可见性42.3.2 符号版本化42.4 初始化和终止函数42.5 预加载共享库42.6 监控动态链接器：LD_DEBUG42.7 总结42.8 习题第43章　进程间通信简介43.1 IPC工具分类43.2 通信工具43.3 同步工具43.4 IPC工具比较43.5 总结43.6 习题第44章　管道和FIFO44.1　概述44.2　创建和使用管道44.3　将管道作为一种进程同步的方法44.4　使用管道连接过滤器44.5　通过管道与Shell命令进行通信：popen44.6　管道和stdio缓冲44.7　FIFO44.8　使用管道实现一个客户端/服务器应用程序44.9　非阻塞I/O44.10　管道和FIFO中read和write的语义44.11　总结44.12　习题第45章　System V IPC介绍45.1　概述45.2　IPC Key45.3　关联数据结构和对象权限45.4　IPC标识符和客户端/服务器应用程序45.5　System V IPC get调用使用的算法45.6　ipcs和ipcrm命令45.7　获取所有IPC对象列表45.8　IPC限制45.9　总结45.10　习题第46章　System V消息队列46.1　创建或打开一个消息队列46.2　交换消息46.2.1　发送消息46.2.2　接收消息46.3　消息队列控制操作46.4　消息队列关联数据结构46.5　消息队列的限制46.6　显示系统中所有消息队列46.7　使用消息队列实现客户端/服务器应用程序46.8　使用消息队列实现文件服务器应用程序46.9　System V消息队列的缺点46.10　总结46.11　习题第47章　System V信号量47.1　概述47.2　创建或打开一个信号量集47.3　信号量控制操作47.4　信号量关联数据结构47.5　信号量初始化47.6　信号量操作47.7　多个阻塞信号量操作的处理47.8　信号量撤销值47.9　实现一个二元信号量协议47.10　信号量限制47.11　System V信号量的缺点47.12　总结47.13　习题第48章　System V共享内存48.1　概述48.2　创建或打开一个共享内存段48.3　使用共享内存48.4　示例：通过共享内存传输数据48.5　共享内存在虚拟内存中的位置48.6　在共享内存中存储指针48.7　共享内存控制操作48.8　共享内存关联数据结构48.9　共享内存的限制48.10　总结48.11　习题第49章　内存映射49.1　概述49.2　创建一个映射：mmap49.3　解除映射区域：munmap49.4　文件映射49.4.1　私有文件映射49.4.2　共享文件映射49.4.3　边界情况49.4.4　内存保护和文件访问模式交互49.5　同步映射区域：msync49.6　其他mmap标记49.7　匿名映射49.8　重新映射一个映射区域：mremap49.9　MAP_NORESERVE和过度利用交换空间49.10　MAP_FIXED标记49.11　非线性映射：remap_file_pages49.12　总结49.13　习题第50章　虚拟内存操作50.1 改变内存保护：mprotect50.2 内存锁：mlock和mlockatt50.3 确定内存驻留性：mincore50.4 建议后续的内存使用模式：madvise50.5 小结50.6 习题第51章　POSIX IPC介绍51.1 API概述51.2 System V IPC与POSIX IPC比较51.3 总结第52章　POSIX消息队列52.1 概述52.2 打开、关闭和断开链接消息队列52.3 描述符和消息队列之间的关系52.4 消息队列特性52.5 交换消息52.5.1 发送消息52.5.2 接收消息52.5.3 在发送和接收消息时设置超时时间52.6 消息通知52.6.1 通过信号接收通知52.6.2 通过线程接收通知52.7 Linux特有的特性52.8 消息队列限制52.9 POSIX和System V消息队列比较52.10 总结52.11 习题第53章　POSIX信号量53.1 概述53.2 命名信号量53.2.1 打开一个命名信号量53.2.2 关闭一个信号量53.2.3 删除一个命名信号量53.3 信号量操作53.3.1 等待一个信号量53.3.2 发布一个信号量53.3.3 获取信号量的当前值53.4 未命名信号量53.4.1 初始化一个未命名信号量53.4.2 销毁一个未命名信号量53.5 与其他同步技术比较53.6 信号量的限制53.7 总结53.8 习题第54章　POSIX共享内存54.1 概述54.2 创建共享内存对象54.3 使用共享内存对象54.4 删除共享内存对象54.5 共享内存APIs比较54.6 总结54.7 习题第55章　文件加锁55.1 概述55.2 使用flock给文件加锁55.2.1 锁继承与释放的语义55.2.2 flock的限制55.3 使用fcntl给记录加锁55.3.1 死锁55.3.2 示例：一个交互式加锁程序55.3.3 示例：一个加锁函数库55.3.4 锁的限制和性能55.3.5 锁继承和释放的语义55.3.6 锁定饿死和排队加锁请求的优先级55.4 强制加锁55.5 /proc/locks文件55.6 仅运行一个程序的单个实例55.7 老式加锁技术55.8 总结55.9 习题第56章　SOCKET：介绍56.1 概述56.2 创建一个socket：socket56.3 将socket绑定到地址：bind56.4 通用socket地址结构：struct sockaddr56.5 流socket56.5.1 监听接入连接：listen56.5.2 接受连接：accept56.5.3 连接到对等socket：connect56.5.4 流socket I/O56.5.5 连接终止：close56.6 数据报socket56.6.1 交换数据报：recvfrom和sendto56.6.2 在数据报socket上使用connect56.7 总结第57章　SOCKET：UNIX DOMAIN57.1 UNIX domain socket地址：struct sockaddr_un57.2 UNIX domain中的流socket57.3 UNIX domain中的数据报socket57.4 UNIX domain socket权限57.5 创建互联socket对：socketpair57.6 Linux抽象socket名空间57.7 总结57.8 习题第58章　SOCKET：TCP/IP网络基础58.1 因特网58.2 联网协议和层58.3 数据链路层58.4 网络层：IP58.5 IP地址58.6 传输层58.6.1 端口号58.6.2 用户数据报协议（UDP）58.6.3 传输控制协议（TCP）58.7 请求注解（RFC）58.8 总结第59章　SOCKET：Internet DOMAIN59.1 Internet domain socket59.2 网络字节序59.3 数据表示59.4 Internet socket地址59.5 主机和服务转换函数概述59.6 inet_pton和inet_ntop函数59.7 客户端-服务器示例（数据报socket）59.8 域名系统（DNS）59.9 /etc/services文件59.10 独立于协议的主机和服务转换59.10.1 getaddrinfo函数59.10.2 释放addrinfo列表：freeaddrinfo59.10.3 错误诊断：gai_strerror59.10.4 getnameinfo函数59.11 客户端-服务器示例（流式socket）59.12 Internet domain socket库59.13 过时的主机和服务转换API59.13.1 inet_aton和inet_ntoa函数59.13.2 gethostbyname和gethostbyaddr函数59.13.3 getserverbyname和getserverbyport函数59.14 UNIX与Internet domain socket比较59.15 更多信息59.16 总结59.17 习题第60章　SOCKET：服务器设计60.1 迭代型和并发型服务器60.2 迭代型UDP echo服务器60.3 并发型TCP echo服务器60.4 并发型服务器的其他设计方案60.5 inetd（Internet超级服务器）守护进程60.6 总结60.7 练习第61章　SOCKET：高级主题61.1 流式套接字上的部分读和部分写61.2 shutdown系统调用61.3 专用于套接字的I/O系统调用：recv和send61.4 sendfile系统调用61.5 获取套接字地址61.6 深入探讨TCP协议61.6.1 TCP报文的格式61.6.2 TCP序列号和确认机制61.6.3 TCP协议状态机以及状态迁移图61.6.4 TCP连接的建立61.6.5 TCP连接的终止61.6.6 在TCP套接字上调用shutdown61.6.7 TIME_WAIT状态61.7 监视套接字：netstat61.8 使用tcpdump来监视TCP流量61.9 套接字选项61.10 SO_REUSEADDR套接字选项61.11 在accept中继承标记和选项61.12 TCP vs UDP61.13 高级功能61.13.1 带外数据61.13.2 sendmsg和recvmsg系统调用61.13.3 传递文件描述符61.13.4 接收发送端的凭据61.13.5 顺序数据包套接字61.13.6 SCTP以及DCCP传输层协议61.14 总结61.15 练习第62章　终端62.1 整体概览62.2 获取和修改终端属性62.3 stty命令62.4 终端特殊字符62.5 终端标志62.6 终端的I/O模式62.6.1 规范模式62.6.2 非规范模式62.6.3 加工模式、cbreak模式以及原始模式62.7 终端线速（比特率）62.8 终端的行控制62.9 终端窗口大小62.10 终端标识62.11 总结62.12 练习第63章　其他备选的I/O模型63.1 整体概览63.1.1 水平触发和边缘触发63.1.2 在备选的I/O模型中采用非阻塞I/O63.2 I/O多路复用63.2.1 select系统调用63.2.2 poll系统调用63.2.3 文件描述符何时就绪？63.2.4 比较select和poll63.2.5 select和poll存在的问题63.3 信号驱动I/O63.3.1 何时发送"I/O就绪"信号63.3.2 优化信号驱动I/O的使用63.4 epoll编程接口63.4.1 创建epoll实例：epoll_create63.4.2 修改epoll的兴趣列表：epoll_ctl63.4.3 事件等待：epoll_wait63.4.4 深入探究epoll的语义63.4.5 epoll同I/O多路复用的性能对比63.4.6 边缘触发通知63.5 在信号和文件描述符上等待63.5.1 pselect系统调用63.5.2 self-pipe技巧63.6 总结63.7 练习第64章　伪终端64.1 整体概览64.2 UNIX98伪终端64.2.1 打开未使用的主设备：posix_openpt64.2.2 修改从设备属主和权限：grantpt64.2.3 解锁从设备：unlockpt64.2.4 获取从设备名称：ptsname64.3 打开主设备：ptyMasterOpen64.4 将进程连接到伪终端：ptyFork64.5 伪终端I/O64.6 实现script（1）程序64.7 终端属性和窗口大小64.8 BSD风格的伪终端64.9 总结64.10 练习附录A 跟踪系统调用附录B 解析命令行选项附录C 对NULL指针做转型附录D 内核配置附录E 更多信息源附录F 部分习题解答

